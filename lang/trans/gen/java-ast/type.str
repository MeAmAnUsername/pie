module gen/java-string/type

imports

  libspoofax/stratego/debug

  signatures/-
  signatures/lex/-
  signatures/impl/-

  signatures/java/types/-

  statsem/pie
  
  gen/idtype-tuples
  gen/util

rules

  p2j-ast-type-sig: UnitTy() -> ClassType("None", None())
  p2j-ast-type-sig: BoolTy() -> BooleanType()
  p2j-ast-type-sig: IntTy()  -> Int()
  p2j-ast-type-sig: StrTy()  -> ClassType("String", None())
  p2j-ast-type-sig: PathTy() -> ClassType("FSPath", None())
  p2j-ast-type-sig: TopTy()  -> ClassType("Object", None())
  p2j-ast-type-sig: NullTy()  -> ClassType("Void", None())

  p2j-ast-type-sig:
    DataTy(occ) -> ClassType(javaClassId, None())
    where 
      JavaTypeKind() := <pie-prop(|"Type", "kind")> occ
    ; <pie-prop(|"Type", "mods"); not(collect-one(?Transient()))> occ
    with  
      javaClassId := <pie-prop(|"Type", "javaClassId")> occ

  p2j-ast-type-sig:
    DataTy(occ) -> ClassType("OutTransient", ClassType(javaClassId, None()))
    where 
      JavaTypeKind() := <pie-prop(|"Type", "kind")> occ
    ; <pie-prop(|"Type", "mods"); collect-one(?Transient())> occ
    with  
      javaClassId := <pie-prop(|"Type", "javaClassId")> occ


  p2j-ast-type-sig: 
    TupleTy(tys) -> ClassType($[Tuple[length]], tys)
    with
      length := <length> tys

  p2j-ast-type-sig: ListTy(ty)     -> $[ArrayList<[<p2j-ast-type-sig> ty]>]
  p2j-ast-type-sig: NullableTy(ty) -> $[[<p2j-ast-type-sig> ty]]
  
rules

  p2j-ast-type-generate-dataclass(|name):
    idTypeTuples -> 
$[public static final class [name] extends [tupleTy]<[tupleTypes]> implements Serializable {
  public [name]([params]) {
    super([callParams]);
  }
  
  @Nullable
  public static [name] fromTuple(@Nullable [tupleTy]<[tupleTypes]> tuple) {
    if (tuple == null) {
      return null;
    }
    return new [name]([tupleNumParams]);
  }
  [getters]
}]
    with
      tupleTy           := $[Tuple[<length> idTypeTuples]]
    ; tys               := <map(Snd)> idTypeTuples
    ; typeStrs          := <map(p2j-ast-type-sig)> tys
    ; idTypeStrTuples   := <zip> (<map(Fst)> idTypeTuples, typeStrs)
    ; getterStrs        := <nmap(type-tuple-to-getter | 1)> idTypeStrTuples
    ; getters           := <pie-concat-nl> getterStrs
    ; paramStrs         := <map(type-tuple-to-param)> idTypeStrTuples
    ; params            := <pie-concat-comma> paramStrs
    ; callParamStrs     := <map(type-tuple-to-call-param)> idTypeStrTuples
    ; callParams        := <pie-concat-comma> callParamStrs
    ; tupleNumParamStrs := <nmap(type-tuple-to-tuple-field-get | 1)> idTypeStrTuples
    ; tupleNumParams    := <pie-concat-comma> tupleNumParamStrs
    ; tupleTypeStrs     := <map(type-tuple-to-type)> idTypeStrTuples
    ; tupleTypes        := <pie-concat-comma> tupleTypeStrs

  type-tuple-to-field: (varId, ty) -> $[public final [ty] [varId];]
  type-tuple-to-type: (varId, ty) -> ty
  type-tuple-to-tuple-field-get(|number): _ -> $[tuple.component[number]()]
  type-tuple-to-getter(|number): (varId, ty) -> 
    $[
    public final [ty] get_[varId]() {
      return component[number]();
    }]
  type-tuple-to-param: (varId, ty) -> $[[ty] [varId]]
  type-tuple-to-call-param: (varId, ty) -> varId
  type-tuple-to-assignment: (varId, ty) -> $[this.[varId] = [varId];]
