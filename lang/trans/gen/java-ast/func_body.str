module gen/java-ast/func_body

imports

  libspoofax/stratego/debug
  nabl2/api

  signatures/-
  signatures/lex/-
  signatures/impl/-
  
  signatures/java/expressions/-
  signatures/java/statements/-
  signatures/java/names/-
  signatures/java/classes/-
  signatures/java/literals/-
  signatures/java/types/-
  
  statsem/pie
  
  gen/java-ast/func_def
  gen/java-ast/binder
  gen/java-ast/type
  gen/idtype-tuples
  gen/util
  gen/debug

rules 

  // tries to apply p2j-ast-exp, returns ""
  try-p2j-ast-exp = pie-try-debug(p2j-ast-exp|"p2j-ast-exp") <+ !NewInstance(None(), [], "Object", [], None(), [])
  
rules // Expression composition

  // p2j-ast-exp: Pie to Java AST expressions
  // Takes a Pie AST Expression node and compiles it to a pair of
  // (List of Java statements, Java Node with an expression for the value of the Pie AST node)
  p2j-ast-exp:
    e@Block(exps) -> result
    with
      numExps              := <length> exps
    ; restExps             := <take(|<dec> numExps)> exps 
    ; restStmts            := <map(try-p2j-ast-exp); map(Fst); concat> restExps
    ; lastExp              := <last> exps
    ; (lastStmts, lastExp) := <try-p2j-ast-exp> lastExp
    ; stmts                := <concat> [restStmts, lastStmts]
    ; blockResultVal       := <newname> "blockResult"
    ; ty                   := <p2j-ast-type-sig> <pie-type> e
    ; resultStmts          := [
      LocVarDeclStm(LocalVarDecl([Final()], ty, [blockResultVal])),
      Block(<concat> [
        [stmts],
        Assign(blockResultVal, lastExp)
      ])
    ]
    ; result                    := (resultStmts, blockResultVal)
    ; <debug(|"End Block (expression): ")> result

rules // Unary expressions
  
  p2j-ast-exp:
    ToNullable(exp) -> <try-p2j-ast-exp> exp // non-primitive Java types are always nullable
  
  p2j-ast-exp:
    n@ToNonNullable(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; tmpVarName         := <newname> "exp"
    ; ty                 := <p2j-ast-type-sig> <pie-type> n
    ; stmts              := <concat> [
        expStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          tmpVarName, 
          InvokeQExp(ExpressionName("Objects"), None(), "requireNonNull", [expVal])
        )]))]
        // Note: I am not sure what the constructor for "Objects" should be. If this
        //       doesn't work, try changing it to something specific for classnames.
        // Note: meaning of this AST:
        //       final [ty] [tmpVarName] = Objects.requireNonNull([expVal]);
      ]
    ; result             := (stmts, tmpVarName)


  p2j-ast-exp:
    Not(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; result             := (expStmts, Not(expVal))

rules // Binary expressions

  // p2j-ast-binexp(combine-vals):
  //   (lExp, rExp) -> (Java statements, Java expression value AST node)
  // a general function for handline a binexp.
  // It takes a strategy combine-vals to combine the values of both sides
  p2j-ast-binexp(combine-vals):
    (lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; stmts             := <concat> [lStmts, rStmts]
    ; exp               := <combine-vals> (lExpVal, rExpVal)
    ; result            := (stmts, exp)
  
  p2j-ast-exp: Eq(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> InvokeQExp(e1, None(), "equals", [e2])\)> (lExp, rExp)
  p2j-ast-exp: Neq(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> Not(InvokeQExp(e1, None(), "equals", [e2]))\)> (lExp, rExp)
  p2j-ast-exp: Lor(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyOr(e1, e2)\)> (lExp, rExp)
  p2j-ast-exp: Land(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyAnd(e1, e2)\)> (lExp, rExp)

rules // Control flow

  p2j-ast-exp:
    If(condExp, branch) -> result
    with
      (condStmts, condExp) := <try-p2j-ast-exp> condExp
    ; (branchStmts, _)     := <try-p2j-ast-exp> branch
    ; stmts                := <concat> [condStmts, [If(condExp, Block(branchStmts))]]
    ; exp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result               := (stmts, exp)
    
  p2j-ast-exp:
    e@IfElse(condExp, trueExp, falseExp) -> result
    with
      (condStmts, condExp)   := <try-p2j-ast-exp> condExp
    ; (trueStmts, trueExp)   := <try-p2j-ast-exp> trueExp
    ; (falseStmts, falseExp) := <try-p2j-ast-exp> falseExp
    ; resultName             := <newname> "ifResult"
    ; trueBlockStmts         := <concat> [trueStmts, [Assign(resultName, trueExp)]]
    ; falseBlockStmts        := <concat> [falseStmts, [Assign(resultName, falseExp)]]
    ; ty                     := <p2j-ast-type-sig> <pie-type> e
    ; stmts                  := <concat> [
      condStmts,
      [
        LocVarDeclStm(LocalVarDecl([Final()], ty, [resultName])),
        IfElse(condExp, Block(trueBlockStmts), Block(falseBlockStmts))
      ]]
    ; result                 := (stmts, resultName)

  p2j-ast-exp:
    Add(lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; stmts             := <concat> [lStmts, rStmts]
    ; lType             := <pie-ast-type> lExp
    ; rType             := <pie-ast-type> rExp
    ; exp               := <p2j-ast-add(|lType, rType)> (lExpVal, rExpVal)
    ; result            := (stmts, exp)

  // p2j-ast-add(|lType, rType): (lExp, rExp) -> Java expression AST Node
  // Helper function that converts the Add into the correct AST Node
  // based on the types of the left and right side (lType and rType)
  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> Add(lExp, rExp)
    where
      (IntTy(), IntTy()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> Add(lExp, rExp)
    where
      (StrTy(), _) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> InvokeQExp(lExp, None(), "appendRelativePath", [rExp])
    // Note: meaning of this AST: [lExp].appendRelativePath([rExp])
    where
      (PathTy(), PathTy()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> InvokeQExp(lExp, None(), "appendSegment", [rExp])
    // Note: meaning of this AST: [lExp].appendSegment([rExp])
    where
      (PathTy(), StrTy()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) ->
      InvokeQExp(
        InvokeQExp(
          ExpressionName("Stream")
        , None()
        , "concat"
        , [ InvokeQExp(lExp, None(), "stream", [])
          , InvokeQExp(
              ExpressionName("Stream")
            , None()
            , "of"
            , [rExp]
            )
          ]
        )
      , None()
      , "collect"
      , [ InvokeQExp(
            ExpressionName("Collectors")
          , None()
          , "toCollection"
          , [MethodReferenceCType(ClassType([], "ArrayList", None()), None())]
          )
        ]
      )
    // Note: meaning of this AST:
    //   Stream.concat(([lExp]).stream(), Stream.of([rExp])).collect(Collectors.toCollection(ArrayList::new))]
    where
      (ListTy(a), a) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) ->
      InvokeQExp(
	    InvokeQExp(
	      ExpressionName("Stream")
	    , None()
	    , "concat"
	    , [ InvokeQExp(FromTerm(Var("lExpStr")), None(), "stream", [])
	      , InvokeQExp(FromTerm(Var("rExpStr")), None(), "stream", [])
	      ]
	    )
	  , None()
	  , "collect"
	  , [ InvokeQExp(
	        ExpressionName("Collectors")
	      , None()
	      , "toCollection"
	      , [MethodReferenceCType(ClassType([], "ArrayList", None()), None())]
	      )
	    ]
	  )
    // Note: meaning of this AST:
    // Stream.concat(([lExp]).stream(), ([rExp]).stream()).collect(Collectors.toCollection(ArrayList::new))]
    where
      (ListTy(a), ListTy(a)) := (lType, rType)


  p2j-exp:
    e@ListComprehension(mapExp, binder, listExp) -> result
    with
      (listStmts, listExpVal) := <try-p2j-ast-exp> listExp
    ; ListTy(listExpElemTy)   := <pie-ast-type> listExp
    ; (mapStmts, mapExpVal)   := <try-p2j-ast-exp> mapExp
    ; (assignments, varId)    := <bind-tuples-to-ast-assignments> (binder, listExpElemTy)
    ; innerStmts              := <concat> [
        assignments,
        mapStmts,
        [Return(mapExpVal)]
        // Note: may need to be Return(Some(mapExpVal))
        // Note: meaning of this AST: return [mapExpVal];
      ]
    ; comprehensionTmpVarName := <newname> "comprehensionResult"
    ; ty                      := <p2j-ast-type-sig> <pie-type> e
    ; stmts                   := <concat> [
        listStmts,
        InvokeQExp(
          InvokeQExp(
            InvokeQExp(listExpVal, None(), "stream", [])
          , None()
          , "map"
          , [ InvokeQExp(
                ExpressionName("Util")
              , None()
              , "throwingLambda"
              , [LambdaExpressionWithBlock(SingleParam("varId"), Block(innerStmts))
                ]
              )
            ]
          )
        , None()
        , "collect"
        , [ InvokeQExp(
              ExpressionName("Collectors")
            , None()
            , "toCollection"
            , [MethodReferenceCType(ClassType([], "ArrayList", None()), None())]
            )
          ]
        )
        // Note: meaning of this AST:
        //   final [ty] [comprehensionTmpVarName] = [listExpVal].stream().map(Util.throwingLambda([varId] -> {
        //     [innerStmts]
        //   })).collect(Collectors.toCollection(ArrayList::new));
      ]
    ; result                     := (stmts, comprehensionTmpVarName)

rules // Binding

  p2j-ast-exp:
    e@ValDec(binder, exp) -> result
    with
      expTy                := <p2j-ast-type-sig> <pie-ast-type> exp
    ; (expStmts, exp)      := <try-p2j-ast-exp> exp
    ; (assignments, varId) := <bind-tuples-to-ast-assignments> (binder, expTy)
    ; stmts                := <concat> [
        expStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], expTy, [VariableDeclInit(varId, exp)]))],
        assignments
      ]
    ; resultExp            := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result               := (stmts, resultExp)
  
  // bind-tuples-to-assignments:
  // (Pie Binder (bind or TBind), Pie ExpressionType) -> (assignments, varName)
  bind-tuples-to-ast-assignments:
    (SingleBinder(bind), _) -> ([], <p2j-ast-bind> bind)
  
  bind-tuples-to-ast-assignments:
    (TupleBinder(binds), expTy) -> result
    with
      varIds       := <map(p2j-ast-bind)> binds
    ; TupleTy(tys) := expTy
    ; javaTys      := <map(p2j-ast-type-sig)> tys
    ; bindList     := <zip> (varIds, javaTys)
    ; tmpVar       := <newname> "tmpTupleVar"
    ; assignments  := <nmap-par(bind-tuple-to-ast | 1, tmpVar)> bindList
    ; result       := (assignments, tmpVar)

  // nmap that passes an extra parameter to the strategy
  nmap-par(s : Int * c * a -> b | i, par) =
    ?[] + [s(|i,par) | nmap-par(s | <inc> i, par)]

  bind-tuple-to-ast(|i, tmpVar):
    (varId, ty) -> LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          varId,
          InvokeQExp(tmpVar, None(), $[component[i]], [])
    )]))

rules // References

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName(varId))> r)
    where
      LocalVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
  
  p2j-ast-exp: 
    Ref(varId) -> <fail>
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 0 := <InputKind>
      
  p2j-ast-exp: 
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName("input"))> r)
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 1 := <InputKind>
      
  p2j-ast-exp: 
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|InvokeQExp("input", None(), $[get_[varId]], []))> r)
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 2 := <InputKind>

  // p2j-ast-ref-add-transient-val(|ast): Pie Ref -> Java reference
  p2j-ast-ref-add-transient-val(|ast):
    ref -> Field(ast, "v")
    where
      <p2j-ast-ref-is-transient> ref
    
  p2j-ast-ref-add-transient-val(|ast):
    ref -> ast
    where
      <not(p2j-ast-ref-is-transient)> ref
  
  // succeeds if the current term is transient
  p2j-ast-ref-is-transient = 
      pie-ast-type
    ; (?DataTy(<id>) <+ ?NullableTy(DataTy(<id>)))
    ; pie-occ-prop(|"mods")
    ; collect-one(?Transient())

rules // Java foreign function calls

  p2j-ast-exp:
    c@Call(funcId, exps) -> result
    where
      JavaForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId           := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; javaMethodId          := <pie-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; callResultName        := <newname> "callResult"
    ; ty                    := <p2j-ast-type-sig> <pie-type> c
    ; stmts                 := <concat> [
        <concat> expsStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          callResultName, 
          InvokeQExp(ExpressionName(javaClassId), None(), javaMethodId, expsVals)
        )]))]
        // Note: I am not sure what the constructor for the javaClassId should be. If this
        //       doesn't work, try changing it to something specific for classnames.
        // Note: meaning of this AST:
        //     final [ty] [callResultName] = [javaClassId].[javaMethodId]([expsVals]);
      ]
    ; result                := (stmts, callResultName)

rules // Qualified function calls

  p2j-ast-exp:
    c@QCall(exp, funcId, argExps) -> result
    with
      (expStmts, expVal)          := <try-p2j-ast-exp> exp
    ; (argExpsStmts, argExpsVals) := <unzip> <map(try-p2j-ast-exp)> argExps
    ; callResultName              := <newname> "callResult"
    ; ty                          := <p2j-ast-type-sig> <pie-type> c
    ; stmts                       := <concat> [
        expStmts, 
        <concat> argExpsStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          callResultName, 
          InvokeQExp(ExpressionName(expVal), None(), funcId, argExpsVals)
        )]))]
        // Note: meaning of this AST:
        //       final [ty] [callResultName] = [expVal].[funcId]([argExpsVals]);]]
      ]
    ; result                          := (stmts, callResultName)

rules // PIE function calls
  
  p2j-ast-exp:
    c@Call(funcId, _) -> <p2j-ast-exp-pie-call(|javaClassId)> c
    where
      PieForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    
  p2j-ast-exp:
    c@Call(funcId, _) -> <p2j-ast-exp-pie-call(|javaClassId)> c
    where
      PieFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-sanitize-class-id> funcId

  // p2j-ast-exp-pie-call(|javaClassId): Call -> (stmts, exp value)
  // Like p2j-ast-exp, but specifically for pie Calls. Is called by the strategies
  // above. javaClassId is the name of the class that represents the Pie function
  p2j-ast-exp-pie-call(|javaClassId):
   c@Call(funcId, exps) -> result
    with
      (expStmts, inputArg) := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> exps
    ; safeJavaClassId      := <string-replace(|".", "_")> javaClassId
    ; callResultName       := <newname> "callResult"
    ; ty                   := <p2j-ast-type-sig> <pie-type> c
    ; stmts                := <concat> [
        expStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          callResultName,
          InvokeQExp(ExpressionName("execContext"), None(), "require", [
            $[_[safeJavaClassId]],
            inputArg
          ])
        )]))]
        // Note: meaning of this AST:
        //       final [ty] [callResultName] = execContext.require(_[safeJavaClassId], [inputArg]);
      ]
    ; result                := (stmts, callResultName)
    ; rules(InjectValues :+= ($[_[safeJavaClassId]], $[[javaClassId]]))

  // p2j-ast-exp-pie-call-inputexp(|javaClassId): exps -> (stmts, input ast node)
  // Converts a list of Pie expressions to a list of statements and an AST node that 
  // can be used as input for a Pie task. Will be either Unit, an arbitrary AST node
  // or an Input AST node for the provided JavaClass (from JavaClassId)
  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> <try-p2j-ast-exp> UnitLit()
    where
      0 := <length> exps

  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      1 := <length> exps
    with
      [exp]  := exps
    ; result := <try-p2j-ast-exp> exp
    
  p2j-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      length := <length> exps
    ; <gt> (length, 1)
    with
      (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(None(), [], javaClassId, ["Input"], None(), expsVals)
      // Note: meaning of this AST:
      //       new [javaClassId].Input([expsVals])
    ; result                := (stmts, exp)

rules // Path operations

  p2j-exp:
    r@RequiresPath(exp, filterOpt, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (filterOpt, stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [InvokeQExp(ExpressionName("execContext"), None(), "require", [expVal, stamperVal])]
        // Note: meaning of this AST:
        //       execContext.require([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)

  p2j-exp:
    GeneratesPath(exp, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (None(), stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [InvokeQExp(ExpressionName("execContext"), None(), "provide", [expVal, stamperVal])]
        // Note: meaning of this AST:
        //       execContext.provide([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)
  
  // p2j-stamper: (filter|None(), stamper) -> (stmts, expression value)
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName("FileSystemStampers"), None(), "modified", []))
    // Note: meaning of this AST: FileSystemStampers.modified()
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName("FileSystemStampers"), None(), "hash", []))
    // Note: meaning of this AST: FileSystemStampers.hash()
  p2j-ast-stamper:
    (filter, Modified()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName("FileSystemStampers"), None(), "modified", [filterVal])
      // Note: meaning of this AST: FileSystemStampers.modified([filterVal])
    ; result             := (stmts, exp)
      
  p2j-ast-stamper:
    (filter, Hash()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName("FileSystemStampers"), None(), "hash", [filterVal])
      // Note: meaning of this AST: FileSystemStampers.hash([filterVal])
    ; result             := (stmts, exp)

  p2j-ast-exp:
    l@ListPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-list|"list")> (l, exp, filterOpt)
  p2j-ast-exp:
    w@WalkPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-walk|"walk")> (w, exp, filterOpt)

  // p2j-ast-dir(create-param-list | funcName):
  //   (astNode, exp, filterOpt) -> (Java statements, Java expression value)
  // Combined function for both ListPath and WalkPath.
  // Input:
  // - a strategy create-params-list which is passed on to p2j-ast-filter-to-params-list.
  // - a function name to call (funcName)
  // - operates on terms that are a Triple of:
  //   + a Pie AST node (ListPath or WalkPath)
  //   + the expression from that AST node (said expression represents a path)
  //   + the filterOption from that AST node. This is also known as a matcher.
  p2j-ast-dir(create-param-list | funcName):
    (astNode, exp, filterOpt) -> result
    with
      (expStmts, expVal)      := <try-p2j-ast-exp> exp
    ; (matcherStmts, matcher) := <p2j-ast-filter> filterOpt
    ; funcParamList           := <p2j-ast-filter-to-params-list(create-param-list)> (filterOpt, matcher)
    ; ty                      := <p2j-ast-type-sig> <pie-type> astNode
    ; expVarName              := <newname> "dirResult"
    ; stmts                   := <concat> [
        expStmts,
        matcherStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          expVarName,
          InvokeQExp(
            InvokeQExp(
              InvokeQExp(
                InvokeQExp(ExpressionName("execContext"), None(), "require", [expVal])
                , None()
                , funcName
                , funcParamList
                )
            , None()
            , "map"
            , [MethodReferenceRType(ClassType([], "FSResource", None()), None(), "getPath")]
            )
          , None()
          , "collect"
          , [ InvokeQExp(
                ExpressionName("Collectors")
              , None()
              , "toCollection"
              , [MethodReferenceCType(ClassType([], "ArrayList", None()), None())]
              )
            ]
          )
        )]))]
        // Note: meaning of this AST:
        //   final [ty] [expVarName] = execContext.require([expVal]).[funcName]([funcParamList])
        //   .map(FSResource::getPath)
        //   .collect(Collectors.toCollection(ArrayList::new));
      ]
    ; result                  := (stmts, expVarName)

  // p2j-ast-filter-to-params-list(create-param-list):
  //   (matcherPie, matcherJava) -> parameter list
  // creates a list of parameters for the call to the dir-function in p2j-ast-dir
  // create-param-list should be one of the p2j-filter-create-param-list-for-X strategies
  p2j-ast-filter-to-params-list(create-param-list):
    (None(), _) -> []
  p2j-ast-filter-to-params-list(create-param-list):
    (matcherPie, matcherJava) -> <create-param-list> matcherJava
    where
      <not(?None())> matcherPie
  
  // p2j-ast-filter-create-param-list-for-[funcName]: matcher -> param list
  // Given a Java AST node for a matcher, create a list of parameters
  // for the Pie API method funcName
  p2j-ast-filter-create-param-list-for-list:
    matcher -> [NewInstance(None(), [], "PathResourceMatcher", [], None(), matcher)]
    // Note: meaning of this AST: new PathResourceMatcher([matcher])
  p2j-ast-filter-create-param-list-for-walk:
    matcher -> [
      NewInstance(None(), [], "PathResourceWalker", [], None(), [
        NewInstance(None(), [], "NoHiddenPathMatcher", [], None(), [])
      ]),
      NewInstance(None(), [], "PathResourceMatcher", [], None(), [matcher])
    ]
    // Note: meaning of these ASTs:
    //   new PathResourceWalker(new NoHiddenPathMatcher())
    //   new PathResourceMatcher([matcher])

  // p2j-ast-filter: Pie filter -> (stmts, Java AST expression value)
  // Important: the return value for the term None() is non-sensical and should not be used.
  // The rule is left here because some p2j-ast-dir will call it but discard the result if it is None()
  p2j-ast-filter:
    None() -> () // Intentionally returns a malformed output, as this result should never be used
  p2j-ast-filter:
    Regex(exp) -> <p2j-ast-filter-common> ("RegexPathMatcher", exp)
  p2j-ast-filter:
    Pattern(exp) -> <p2j-ast-filter-common> ("PatternPathMatcher", exp)
  p2j-ast-filter:
    Patterns(exp) -> <p2j-ast-filter-common> ("PatternsPathMatcher", exp)
  p2j-ast-filter:
    Extension(exp) -> <p2j-ast-filter-common> ("ExtensionPathMatcher", exp)
  p2j-ast-filter:
    Extensions(exp) -> <p2j-ast-filter-common> ("ExtensionsPathMatcher", exp)

  // p2j-ast-filter-common: (Pie matcher, Pie exp) -> (stmts, Java AST expression value)
  p2j-ast-filter-common:
    (matcher, exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; resultExp          := NewInstance(None(), [], matcher, [], None(), [expVal])
    // Note: meaning of this AST: new [matcher]([expVal])
    ; result                := (expStmts, resultExp)


  p2j-ast-exp:
    r@ReadPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-type> r
    ; readResultName     := <newname> "readResult"
    ; stmts              := <concat> [
        expStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          readResultName,
          InvokeQExp(ExpressionName("Util"), None(), "readToString", [expVal])
        )]))]
        // Note: I am not sure what the constructor for "Util" should be. If this
        //       doesn't work, try changing it to something specific for classnames.
        // Note: meaning of this AST:
        //       final [ty] [readResultName] = Util.readToString([expVal]);
      ]
    ; result             := (stmts, readResultName)

  p2j-ast-exp:
    e@ExistsPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-type> e
    ; existsResultName   := <newname> "existsResult"
    ; stmts              := <concat> [
        expStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], ty, [VariableDeclInit(
          existsResultName,
          InvokeQExp(
            InvokeQExp(ExpressionName("Files"), None(), "exists", [expVal]),
            None(),
            "getJavaPath",
            []
          )
        )]))]
        // Note: I am not sure what the constructor for "Util" should be. If this
        //       doesn't work, try changing it to something specific for classnames.
        // Note: meaning of this AST:
        //       final [ty] [existsResultName] = Files.exists([expStr].getJavaPath());
      ]
    ; result             := (stmts, existsResultName)

rules // Early return and failure

  p2j-ast-exp:
    Return(exp) -> result
    with
      (expStmts, expVal) := <p2j-ast-pie-func-impl-returnvalue> exp
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; stmts              := <concat> [expStmts, [Return(expVal)]]
    ; result             := (stmts, resultExp)

  p2j-ast-exp:
    Fail(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; stmts              := <concat> [
        expStmts,
        [Throw(NewInstance(None(), [], "ExecException", [], None(), InvokeQExp(
          expVal, None(), "toString", [])))]
        // Note: meaning of this AST: throw new ExecException([expVal].toString());
      ]
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result             := (stmts, resultExp)

rules // Literals

  p2j-ast-exp: UnitLit()        -> ([], Field(ExpressionName("None"), "instance"))
  p2j-ast-exp: BoolLit(True())  -> ([], NewInstance(None(), [], "Boolean", [], None(), [True()]))
  p2j-ast-exp: BoolLit(False()) -> ([], NewInstance(None(), [], "Boolean", [], None(), [False()]))
  p2j-ast-exp: IntLit(i)        -> ([], NewInstance(None(), [], "Integer", [], None(), [Deci(<int-to-string> i)]))
  p2j-ast-exp: NullLit()        -> ([], Null())


  p2j-ast-exp:
    TupleLit(exps) -> result
    with
      (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := InvokeQExp(ExpressionName("Util"), None(), "tuple", expsVals)
      //  Note: meaning of this AST: Util.tuple([expsVals])
    ; result                := (stmts, exp)
    
  p2j-ast-exp:
    ListLit(exps) -> result
    with
      (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(None(), [], "ArrayList", [], Some(Diamond()), [
        InvokeQExp(ExpressionName("Arrays"), None(), "asList", expsVals)
      ])
    //  Note: meaning of this AST: new ArrayList<>(Arrays.asList([expsVals]))
    ; result                := (stmts, exp)

rules // Interpolated string literal

  p2j-ast-exp:
    StrLit(parts) -> result
    with
      (partsStmts, partsExps) := <unzip> <map(p2j-ast-strpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := <reduce(p2j-ast-add-strings)> partsExps
    ; result                  := (stmts, exp)

  // Replace all escaped \$ with $. Note: "\\$" because the \ needs to be escaped in stratego.
  // todo: Check if simply replacing is fine, or if it is possible that it is actually a $,
  // e.g. "\\$foo" should evaluate to "\<valueOfFoo>"
  p2j-ast-strpart:
    Str(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-strpart:
    StrInterpRef(refExp) -> <try-p2j-ast-exp> refExp
      
  p2j-ast-strpart:
    StrInterpExp(exp) -> <try-p2j-ast-exp> exp

  p2j-ast-add-strings:
    (e1, e2) -> Add(e1, e2)

rules // Interpolated path literal

  p2j-ast-exp:
    e@PathLit(prefix, parts) -> result
    with
      (partsStmts, partsExps) := <unzip> <map(p2j-ast-pathpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := NewInstance(None(), [], "FSPath", [], None(), [
        Add(StringLiteral($["[prefix]"]), <reduce(p2j-ast-add-strings)> parts)
      ])
      // Note: meaning of this AST: new FSPath("[prefix][partsStr]")
    ; result                      := (stmts, exp)

  p2j-ast-pathpart:
    Path(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-pathpart:
    PathInterpRef(refExp) -> <try-p2j-ast-exp> refExp

  p2j-ast-pathpart:
    PathInterpExp(exp) -> <try-p2j-ast-exp> exp
