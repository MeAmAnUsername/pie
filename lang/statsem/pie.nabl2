module statsem/pie

imports

  signatures/-

signature

  namespaces Type Func Var

  name resolution

    labels          P I
    order           D < I, D < P, I < P
    well-formedness P*.I*

  constructors

    FuncTy : list(Type) * Type -> Type
    TopTy  : Type
    NullTy : Type

    JavaTypeKind : TypeKind

    JavaForeignFuncKind   : FuncKind
    PieForeignFuncKind : FuncKind
    PieFuncKind     : FuncKind

    LocalVarKind : VarKind
    InputVarKind : VarKind

  functions

    addType : (Type * Type) -> Type {
      (IntTy()  , IntTy()  ) -> IntTy(),
      (StrTy()  , _        ) -> StrTy(),
      (PathTy() , PathTy() ) -> PathTy(),
      (PathTy() , StrTy()  ) -> PathTy(),
      (ListTy(a), a        ) -> ListTy(a),
      (ListTy(a), ListTy(a)) -> ListTy(a)
    }

    typeToOcc : (Type * Occurrence * Occurrence) -> Occurrence {
      (DataTy(occ), occ_def_str, occ_def_path) -> occ,
      (StrTy()    , occ_def_str, occ_def_path) -> occ_def_str,
      (PathTy()   , occ_def_str, occ_def_path) -> occ_def_path
    }

rules // Init

  init ^ (s_root) :=
    new s_root,
    // Create definitions in type namespace for primitive types
    Type{StrTy() } <- s_root, new s_str , s_str  -P-> s_root, Type{StrTy() } =I=> s_str,
    Type{PathTy()} <- s_root, new s_path, s_path -P-> s_root, Type{PathTy()} =I=> s_path,
    // Add functions to string types
    Func{"replace"}          <- s_str,  Func{"replace"}          : FuncTy([StrTy(), StrTy()], StrTy())!,
    // Add functions to path types
    Func{"extension"}        <- s_path, Func{"extension"}        : FuncTy([], NullableTy(StrTy()))!,
    Func{"replaceExtension"} <- s_path, Func{"replaceExtension"} : FuncTy([StrTy()], PathTy())!,
    Func{"resolve"}          <- s_path, Func{"resolve"}          : FuncTy([StrTy()], PathTy())!.

rules // Program

  [[ Program(Module(moduleList), package, imports, defs) ^ (s_root) ]] :=
    new s_file,
    s_file -P-> s_root,
    modules [[ moduleList ^ (s_root, s_root) ]],
    Map1 [[ defs ^ (s_file) ]],
    // todo: imports
    distinct/name D(s_file)/Type | error "Duplicate types" @NAMES,
    distinct/name D(s_file)/Func | error "Duplicate functions" @NAMES.

rules // None

  [[ None() ^ (s) ]] := true.

rules // Module scope generation

  modules [[ [first|rest] ^ (s, s_root) ]] :=
    new s_sub_module,
    Mod{first} <- s,
    Mod{first} =I=> s_sub_module,
    modules [[ rest ^ (s_sub_module, s_root) ]].

  modules [[ [] ^ (s, s_root) ]] :=
    s -P-> s_root. // s can resolve things from the root module
