module gen/util

imports

  libspoofax/stratego/debug
  statix/api

  signatures/-
  statics/constructors

// todo: remove commented code
rules // Generic strategies for getting properties and types of anything

  // returns a named property set by statix analysis
  // name: the name of the property to get
  // node: the AST term to get the property from
  pie-get-property(|name):
    node -> val
    with
      a    := <stx-get-ast-analysis> node
    ; val := <stx-get-ast-property(|a, name)> node

  // returns a named property set by statix analysis
  // Depracated, use todo: pie-ast-ref-prop(|name) instead.
  // Todo: remove this strategy
  // _: unused
  // name: the name of the property to get
  // term: the AST term to get the property from
  pie-prop(|_, name) = pie-get-property(|name)

//  pie-prop(|ns, prop):
//    t -> <pie-occ-prop(|prop)> t
//    where
//      <nabl2-get-occurrence-ns> t
//
//  pie-prop(|ns, prop):
//    t -> <pie-ast-ref-prop(|ns, prop)> t
//    where
//      <not(nabl2-get-occurrence-ns); is-string> t

  // return the type of an ast node
  pie-get-type:
    node -> type
    with
      a    := <stx-get-ast-analysis> node
    ; type := <stx-get-ast-type(|a)> node

  // get context value [name] from scope
  pie-get-context(|name):
    scope -> val
    with
      a    := <AstAnalysis>
    ; vals := <stx-get-scopegraph-data(|a, "statics/base!context")> scope
    ; matches := <filter(matches-occurrence(|name))> vals
    ; [(val)] := matches

    matches-occurrence(|name): (name', val) -> val
    where
      name := <rm-annotations> name'

  // get the list of modifiers for a data type.
  pie-get-data-mods:
    data_scope -> mods
    with
      a    := <AstAnalysis>
    ; mods := <stx-get-scopegraph-data(|a, "statics/base!data_mods")> data_scope

rules // AST type

//  pie-ast-type = nabl2-get-ast-type

imports
  statix/runtime/ast

rules // Property of reference in the AST

  // returns a named property set by statix analysis on a declaration.
  // First resolves this term to a declaration and then gets the property from the declaration.
  // name: the name of the property to get
  // term: the term to get the property from. This term needs to be resolvable, i.e. it needs to have a reference set
  pie-ast-ref-prop(|name):
    node -> val
    with
      a    := <stx-get-ast-analysis> node
      // the following line uses an internal Statix strategy.
      // todo: use external api when available (stx-get-ast-ref)
      // (Also remove import above when switching)
    ; decl := <stx--get-ast-property(|a, Ref())> node
    ; val  := <stx-get-ast-property(|a, name)> decl

  // returns a named property set by statix analysis
  // Depracated, use todo: pie-ast-ref-prop(|name) instead.
  // Todo: remove this strategy
  // _: unused
  // name: the name of the property to get
  // term: the term to get the property from
  pie-ast-ref-prop(|_, name) = pie-ast-ref-prop(|name)


//  pie-ast-ref-prop(|ns, prop):
//    term -> val
//    with
//      a      := <AstAnalysis>
//    ; refOcc := <nabl2-mk-occurrence(|ns)> term
//    ; defOcc := <nabl2-get-resolved-name(|a); Fst> refOcc
//    ; val    := <nabl2-get-property(|a, prop)> defOcc

//  pie-ast-ref-type(|ns) = pie-ast-ref-prop(|ns, "type")

rules // Property of occurrence

//  pie-occ-prop(|prop):
//    occ -> val
//    with
//      a   := <AstAnalysis>
//    ; val := <nabl2-get-property(|a, prop)> occ
//
//  pie-occ-type = pie-occ-prop(|"type")

rules

  pie-set-ast-analysis:
    ast -> ast
    with
      rules(AstAnalysis : _ -> <stx-get-ast-analysis> ast)

rules

  pie-sep-nl    = separate-by(|"\n")
  pie-sep-comma = separate-by(|", ")
  pie-sep-space = separate-by(|" ")

  pie-remove-emptystrings = filter(not(?""))

  pie-sep-concat(|sep) = pie-remove-emptystrings; separate-by(|sep); concat-strings
  pie-concat-nl = pie-sep-concat(|"\n")
  pie-concat-comma = pie-sep-concat(|", ")
  pie-concat-space = pie-sep-concat(|" ")
  pie-concat-commanl = pie-sep-concat(|",\n")

  pie-prepend-comma-nonempty:
    [] -> []
  pie-prepend-comma-nonempty:
    list -> [", "|list]
    where
      <not(?[])> list

rules

  pie-sanitize-class-id = string-replace(|"-", "_")

rules

  error(|message) = debug(|message); fail

rules

  // fold-left(s): list -> result of folding
  // types:
  //   argument: List(a)
  //   s: (a, a) -> a
  // fold a list from the left.
  // Also works on lists with only one element (simply returns that element)
  fold-left(s):
    [] -> <fail>

  fold-left(s):
    [x | []] -> x

  fold-left(s):
    [x | [y | rest]] -> <fold-left(s)> [<s> (x, y) | rest]

rules // project specific helper strategies

  // transforms a PIE ModuleList to a list
  moduleListToList: NoModuleList() -> []
  moduleListToList: ModuleList(list) -> list

  // transforms a PIE Module or a PIE ModuleStmt to a list of module names
  moduleToList: Module(moduleList, name) -> <concat> [<moduleListToList> moduleList, [name]]
  moduleToList: ModuleStmt(mod) -> <moduleToList> mod

  syntacticToSemanticType: ty -> <pie-get-type> ty
