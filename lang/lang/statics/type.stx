module statics/type

imports

  signatures/constructors-sig
  signatures/data-sig
  signatures/type-sig
  statics/base
  statics/module

rules // operations on types

  /**
   * inherits(s_sub, s_super) -> res
   * Returns TRUE() if s_sub inherits from (can be reached by only
   * following INHERIT edges from) s_super or is equal to s_super,
   * FALSE() otherwise.
   */
  inherits : scope * scope -> BOOLEAN
  inherits(s_sub, s_super) = inherits_1(paths) :-
    query () filter P? (INHERIT P)* INHERIT? and { s_data :- s_data == s_super } in s_sub |-> paths.

    inherits_1 : list((path * scope)) -> BOOLEAN
    inherits_1([]) = FALSE().
    inherits_1([_|_]) = TRUE().

  /**
   * subtype(T1, T2)
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   * Will unify unbound variables if possible.
   */
  subtype : TYPE * TYPE
  subtypes maps subtype(list(*), list(*))
  subtype(NullType(), NullableType(_)).
  subtype(T1, NullableType(T2)) :- subtype(T1, T2).
  subtype(NullableType(T1), NullableType(T2)) :- subtype(T1, T2).
  subtype(EmptyListType(), ListType(_)).
  subtype(d1@DataType(_), d2@DataType(_)) :- isSubtype(d1, d2) == TRUE().
  subtype(_, TopType()).
  subtype(T1, T2) :- T1 == T2.

  /**
   * isSubtype(T1, T2)
   * Returns TRUE() if type T1 is a non-strict subtype of type T2, FALSE() otherwise.
   * May fail on unbound variables.
   */
  isSubtype : TYPE * TYPE -> BOOLEAN
  isSubtype(NullType(), NullableType(_)) = TRUE().
  isSubtype(T1, NullableType(T2)) = isSubtype(T1, T2).
  isSubtype(NullableType(T1), NullableType(T2)) = isSubtype(T1, T2).
  isSubtype(EmptyListType(), ListType(_)) = TRUE().
  isSubtype(DataType(s_sub), DataType(s_super)) =
    isSubtypeDataType(s_sub, s_super, inherits, type_args, s_super_def)
  :-
    inherits(s_sub, s_super_def) == inherits,
    getTypeArgs(s_super) == type_args,
    findGenericDef(s_super) == s_super_def.
    
      // Get generic definition of s_data. s_data can be either an instance or the generic def itself.
      findGenericDef : scope -> scope
      findGenericDef(s_data) = getScope(occ) :-
        query () filter P? min P < $ in s_data |-> [occ].

    isSubtypeDataType : scope * scope * BOOLEAN * list((TYPEID * TYPE)) * scope -> BOOLEAN
    isSubtypeDataType(s_data, s_data, TRUE(), _, _) = TRUE(). // optimization: s_sub == s_super
    isSubtypeDataType(_, _, FALSE(), _, _) = FALSE(). // s_sub does not inherit from the generic def of s_super, not subtypes
    isSubtypeDataType(_, _, TRUE(), [], _) = TRUE().  // s_super is a generic defintion and s_sub inherits from it, s_sub is a subtype by definition
    isSubtypeDataType(s_sub, s_super, TRUE(), [_|_], s_super_def) = isTypeArgsCompatible(s_sub_super_instance, s_super) :-
      query ()
        filter INHERIT? (P INHERIT)*
           and { s :- getGenericDef(s) == s_super_def }
            in s_sub |-> [(_, s_sub_super_instance)].
      

/*

Steps:
1. Make sure that they could be subtypes: inherits(s_sub, s_super)
2. Case 1: equal instances: isTypeArgsCompatible(s_sub, s_super)
3. Case 2: equal defs: s_sub == s_super
4. Case 3: s_sub is an instance of s_super: (subtype by definition)
5. Case 4: s_sub is strict subtype of s_super
6. Case 4a: s_super is definition: (s_sub is subtype by definition)
7. Case 4b: s_super is an instance of s_super_def:
  7.1: get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def
  7.2: isTypeArgsCompatible(s_sub_super_instance, s_super)


Simplify:
1. Make sure that they could be subtypes: if !inherits(s_sub, findGenericDef(s_super)) then FALSE()  <-- WRONG!!, only holds if s_super is a generic def!!
2. If s_super is a definition, s_sub is a subtype by definition: if getTypeArgs(s_super) == [] then TRUE()
3. Else: s_super is an instance. Find s_super_def by following P edge: getGenericDef(s_super) == s_super_def
[note] s_sub is either an instance of s_super_def, or an instance or generic def of a strict subtype of s_super_def. 
4. Get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def:
     query ()
       filter INHERIT? (P INHERIT)*
          and { s :- getGenericDef(s) == s_super_def }
           in s_sub |-> [(_, s_sub_super_instance)]
5. Check if instances are compatible: isTypeArgsCompatible(s_sub_super_instance, s_super)

inherits(s_sub, s_super):     checks that s_sub has a path to s_super via alternating INHERIT|P edges
isTypeArgsCompatible(s1, s2): given two instances of the same data type, check if s1 is a subtype of s2
getTypeArgs(s_data):          get all type arguments defined in s_data.
getGenericDef(s_data):        Get generic definition of s_data. Requires that s_data is an instance.
findGenericDef(s_data):       Get generic definition of s_data. s_data can be either an instance or the generic def itself.
*/

    // check if s1 is compatible with s2. Assumes s1 is an instance of data
    // type dt and that s2 is either also an instance or the generic definition
    isTypeArgsCompatible : scope * scope -> BOOLEAN
    isTypeArgsCompatible(s1, s2) = isTypeArgsCompatible_1(s1, s2, getGenericDef(s1)).

      // Get generic definition for instance.
      getGenericDef : scope -> scope
      getGenericDef(s_data_instance) = getScope(occ) :-
        query () filter P in s_data_instance |-> [occ].

      // s1 is an instance
      // s2 is either an instance or a data definition.
      // third argument is data definition
      isTypeArgsCompatible_1 : scope * scope * scope -> BOOLEAN
      isTypeArgsCompatible_1(s1, s2, s2) = TRUE().
        // s2 is a generic data definition, s1 is an instance of it.
        // s1 is a subtype by definition.

      isTypeArgsCompatible_1(s1, s2, s_data_def) =
        // s2 is an instance of s_data_def
        allTrue(isTypeArgsCompatible_2(getTypeArgs(s1), s2)).

        getTypeArgs : scope -> list((TYPEID * TYPE))
        getTypeArgs(s_data) = getArgTypes(occs) :-
          query generic_arg in s_data |-> occs.

          getArgType : (path * (TYPEID * TYPE)) -> (TYPEID * TYPE)
          getArgTypes maps getArgType(list(*)) = list(*)
          getArgType((path, arg_ty)) = arg_ty.

      isTypeArgCompatible : (TYPEID * TYPE) * scope -> BOOLEAN
      isTypeArgsCompatible_2 maps isTypeArgCompatible(list(*), *) = list(*)
      isTypeArgCompatible((name, ty1), s2) =
        isTypeArgCompatible_1(ty1, resolveUniqueTypeArg(s2, name, name)).

        isTypeArgCompatible_1 : TYPE * TYPE -> BOOLEAN
        isTypeArgCompatible_1(ty, ty) = TRUE().
        isTypeArgCompatible_1(DataType(s1), DataType(s2)) = isTypeEqual(s1, s2).
        isTypeArgCompatible_1(T1, T2) = FALSE().

        isTypeEqual : scope * scope -> BOOLEAN
        isTypeEqual(s1, s2) = andB(isInstanceOf(s1, s2), isTypeArgsCompatible(s1, s2)).

        isInstanceOf: scope * scope -> BOOLEAN
        isInstanceOf(s1, s2) = isInstanceOf_listNonEmpty(occs) :-
          query () filter P in s1 |-> occs.

          isInstanceOf_listNonEmpty : list((path * scope)) -> BOOLEAN
          isInstanceOf_listNonEmpty([]) = FALSE().
          isInstanceOf_listNonEmpty([_|_]) = TRUE().

  isSubtype(_, TopType()) = TRUE().
  isSubtype(T1, T2) = isSubtypeHelper(T1, T2).

  // this rule is here to prevent "overlapping rules" error
  // on isSubtype(T, NullableType(T))
  // todo: can remove this now?
  isSubtypeHelper : TYPE * TYPE -> BOOLEAN
  isSubtypeHelper(T, T) = TRUE().
  isSubtypeHelper(_, _) = FALSE().

  /**
   * isAllSubTypes(T1s, T2s)
   * Returns TRUE if the types in [T1s] are pairwise subtypes of [T2s], FALSE
   * otherwise. Also returns FALSE if the lists don't have the same length.
   * This is useful for comparing parameter lists of functions.
   * Delegates to isSubtype.
   */
  isAllSubTypes : list(TYPE) * list(TYPE) -> BOOLEAN
  isAllSubTypes([], []) = TRUE().
  isAllSubTypes(Ts@[_|_], []) = FALSE().
  isAllSubTypes([], Ts@[_|_]) = FALSE().
  isAllSubTypes([T1|T1s], [T2|T2s]) = andB(isSubtype(T1, T2), isAllSubTypes(T1s, T2s)).

  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  /**
   * makeNullable(ty)
   * Make Type [ty] nullable if it is not already.
   * This returns either NullType() or NullableType(_)
   */
  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(T) = NullableType(T).

  /**
   * lub(T1, T2)
   * Returns the least upper bound of types [T1] and [T2].
   */
  lub : TYPE * TYPE -> TYPE
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(NullableType(T1), NullableType(T2)) = NullableType(lub(T1, T2)).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(DataType(s1), DataType(s2)) = lub_datatype(paths, s1, s2) :-
    // find all scopes from s1 that s2 inherits from, take the shortest one.
    query ()
      filter INHERIT* and { s_super :- inherits(s2, s_super) == TRUE() }
      min $ < INHERIT in s1 |-> paths.

    lub_datatype : list((path * scope)) * scope * scope -> TYPE
    lub_datatype([], _, _) = TopType().
    lub_datatype([(_, s_data_common)], s1, s2) = DataType(emptyScope(s)) :-
      false | error $[todo: lub for datatypes has not been implemented].
      // todo: propagate both type arguments up to s, return the data type if
      // eventual data types match, otherwise keep going up the type list until
      // either the type arguments do match or there is no more supertype.
      // pseudocode (outdated):
      //   common_type_args1 == propagateTypeArgsToSupertypeUntil(s, s1),
      //   common_type_args2 == propagateTypeArgsToSupertypeUntil(s, s2),
      //   return_ty == returnIfCompatibleOrPropagateUntilTopType(s_data_common, common_type_args1, common_type_args2).
      //
      //   returnIfCompatibleOrPropagateUntilTopType(TRUE(), s_data, args1, args2) = firstTrueT(
      //     (is_compatible, DataType(s_data, compatible_args)),
      //     returnIfCompatibleOrPropagateUntilTopType_1(hasSuper(s_data), s_data, args1, args2))
      //   :-
      //     isCompatible(args1, args2) == (is_compatible, compatible_args).
      //
      //   returnIfCompatibleOrPropagateUntilTopType_1(FALSE(), _, _, _) = TopType().
      //   returnIfCompatibleOrPropagateUntilTopType_1(TRUE(), s_data, args1, args2) =
      //     returnIfCompatibleOrPropagateUntilTopType(getSuper(s_data), args1, args2).

  lub(T1, T2) = firstTrueT([
    (isSubtype(T1, T2), T2),
    (isSubtype(T2, T1), T1)],
    TopType()).


  /**
   * listLub(list)
   * Returns the least upper bound of a list of types.
   */
  listLub : list(TYPE) -> TYPE
  listLub([]) = TopType() :- false | error "listLub is not well-defined for an empty list".
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).

  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :- orB(isSubtype(T1, T2), isSubtype(T2, T1)) == TRUE().

rules

  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)

  typeOf(s, injector@BaseType2Type(base_type)) = ty@typeOfBaseType(s, base_type) :-
    @base_type.type := ty,
    @injector.type := ty.

  typeOf(s, tm@TypeMod2Type(nt@NullableTy(ty))) = type@NullableType(typeOfBaseType(s, ty)) :-
    @nt.type := type,
    @tm.type := type.

  typeOfBaseType : scope * BaseType -> TYPE
  typeOfBaseType(_, UnitTy()) = UnitType().
  typeOfBaseType(_, BoolTy()) = BoolType().
  typeOfBaseType(_, IntTy())  = IntType().
  typeOfBaseType(_, StrTy())  = StrType().
  typeOfBaseType(_, PathTy()) = PathType().
  typeOfBaseType(s, DataTy2BaseType(data_ty)) = ty@typeOfDataTy(s, data_ty) :-
    @data_ty.type := ty.
  typeOfBaseType(s, TupleTy(tys)) = TupleType(typesOf(s, tys)).
  typeOfBaseType(s, ListTy(ty)) = ListType(typeOf(s, ty)).
  typeOfBaseType(s, SupplierTy(ty)) = SupplierType(typeOf(s, ty)).

  typeOfDataTy : scope * DataTy -> TYPE
  typeOfDataTy(s, DataTy(modules, name, type_args)) = DataType(s_data) :-
    {module_scopes}
    new s_data,
    !root[getRoot(s)] in s_data,
    resolveModuleListToFile(s, modules) == module_scopes,
    genericArgsOk(s, s_data, type_args, resolveUniqueDataInScopes(s, module_scopes, name), name).

    genericArgsOk : scope * scope * TypeArgs * (BOOLEAN * scope) * TYPEID
    genericArgsOk(_, _, type_args, (FALSE(), _), name). // error generated by resolveUniqueDataInScopes
    genericArgsOk(s, s_data, TypeArgs(type_args), (TRUE(), s_data_def), _) :-
      s_data -P-> s_data_def,
      genericArgsOk_1(s, s_data, getGenericParams(s_data_def), type_args).

    genericArgOk : scope * scope * GenericParam * TypeBound
    genericArgsOk_1 maps genericArgOk(*, *, list(*), list(*))
    genericArgOk(s, s_data, GenericParam(name, upper_bound), arg) :-
      {upper_bound_ty arg_ty}
      typeOfUpperBound(s, s_data, upper_bound) == upper_bound_ty,
      typeOfTypeBound(s, arg, upper_bound_ty) == arg_ty,
      declareGenericArg(s_data, name, arg_ty).

    typeOfTypeBound : scope * TypeBound * TYPE -> TYPE
    typeOfTypeBound(s, Wildcard(), upper_bound) = upper_bound. // todo: incorrect, should use proper wildcard semantics
    typeOfTypeBound(s, Type2TypeBound(arg), upper_bound_ty) = arg_ty :-
      typeOf(s, arg) == arg_ty,
      subtype(arg_ty, upper_bound_ty) | error $[Type mismatch: [arg_ty] is not within upper bound [upper_bound_ty]].

  /**
   * getScopeFromType(s, ty)
   * Returns the scope with methods associated with type [ty]
   */
  getScopeFromType : scope * TYPE -> scope
  getScopeFromType(s, DataType(s_data)) = s_data.
