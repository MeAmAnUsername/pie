module statics/type

imports

  signatures/constructors-sig
  signatures/data-sig
  signatures/type-sig
  statics/base
  statics/util
  statics/module
  statics/data // todo: remove

rules // operations on types

  /**
   * inherits(s_sub, s_super) -> res
   * Returns TRUE() if s_sub inherits from (can be reached by only
   * following INHERIT edges from) s_super or is equal to s_super,
   * FALSE() otherwise.
   */
  inherits : scope * scope -> BOOLEAN
  inherits(s_sub, s_super) = inherits_1(paths) :-
    query () filter P? (INHERIT P)* INHERIT? and { s_data :- s_data == s_super } in s_sub |-> paths.

    inherits_1 : list((path * scope)) -> BOOLEAN
    inherits_1([]) = FALSE().
    inherits_1([_|_]) = TRUE().

  /**
   * subtype(T1, T2)
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   * Will unify unbound variables if possible.
   */
  assignableTo : TYPE * TYPE
  listAssignableTo maps assignableTo(list(*), list(*))
  assignableTo(NullType(), NullableType(_)).
  assignableTo(T1, NullableType(T2)) :- assignableTo(T1, T2).
  assignableTo(NullableType(T1), NullableType(T2)) :- assignableTo(T1, T2).
  assignableTo(EmptyListType(), ListType(_)).
  assignableTo(d1@DataType(_), d2@DataType(_)) :- isAssignableTo(d1, d2) == TRUE().
  assignableTo(_, TopType()).
  assignableTo(BottomType(), _).
  assignableTo(T1@WildcardType(_, _), T2) :- isAssignableTo(T1, T2) == TRUE().
  assignableTo(T1, T2@WildcardType(_, _)) :- isAssignableTo(T1, T2) == TRUE().
  assignableTo(T1, T2) :- T1 == T2.

  /**
   * isAssignableTo(T1, T2) = bool
   * Returns TRUE() if type T1 is a non-strict subtype of type T2, FALSE() otherwise.
   * May fail on unbound variables.
   */
  isAssignableTo : TYPE * TYPE -> BOOLEAN
  isAssignableTo(NullType(), NullableType(_)) = TRUE().
  isAssignableTo(T1, NullableType(T2)) = isAssignableTo(T1, T2).
  isAssignableTo(NullableType(T1), NullableType(T2)) = isAssignableTo(T1, T2).
  isAssignableTo(EmptyListType(), ListType(_)) = TRUE().
  isAssignableTo(DataType(s_sub), DataType(s_super)) =
    isAssignableTo_dataTypes(s_sub, s_super, inherits, type_args, s_super_def)
  :-
    findGenericDef(s_super) == s_super_def,
    inherits(s_sub, s_super_def) == inherits,
    getTypeArgs(s_super) == type_args.

      // Get generic definition of s_data. s_data can be either an instance or the generic def itself.
      findGenericDef : scope -> scope
      findGenericDef(s_data) = getScope(occ) :-
        query () filter P? min P < $ in s_data |-> [occ].

    isAssignableTo_dataTypes : scope * scope * BOOLEAN * list((TYPEID * TYPE)) * scope -> BOOLEAN
    isAssignableTo_dataTypes(s_data, s_data, TRUE(), _, _) = TRUE(). // optimization: s_sub == s_super
    isAssignableTo_dataTypes(_, _, FALSE(), _, _) = FALSE(). // s_sub does not inherit from the generic def of s_super, not subtypes
    isAssignableTo_dataTypes(_, _, TRUE(), [], _) = TRUE().  // s_super is a generic definition and s_sub inherits from it, s_sub is a subtype by definition
    isAssignableTo_dataTypes(s_sub, s_super, TRUE(), [_|_], s_super_def) = isTypeArgsCompatible(s_sub_super_instance, s_super) :-
      query ()
        filter INHERIT? (P INHERIT)*
           and { s :- getGenericDef(s) == s_super_def }
            in s_sub |-> [(_, s_sub_super_instance)].


/*

Steps:
1. Make sure that they could be subtypes: inherits(s_sub, s_super)
2. Case 1: equal instances: isTypeArgsCompatible(s_sub, s_super)
3. Case 2: equal defs: s_sub == s_super
4. Case 3: s_sub is an instance of s_super: (subtype by definition)
5. Case 4: s_sub is strict subtype of s_super
6. Case 4a: s_super is definition: (s_sub is subtype by definition)
7. Case 4b: s_super is an instance of s_super_def:
  7.1: get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def
  7.2: isTypeArgsCompatible(s_sub_super_instance, s_super)


Simplify:
1. Make sure that they could be subtypes: if !inherits(s_sub, findGenericDef(s_super)) then FALSE()  <-- WRONG!!, only holds if s_super is a generic def!!
2. If s_super is a definition, s_sub is a subtype by definition: if getTypeArgs(s_super) == [] then TRUE()
3. Else: s_super is an instance. Find s_super_def by following P edge: getGenericDef(s_super) == s_super_def
[note] s_sub is either an instance of s_super_def, or an instance or generic def of a strict subtype of s_super_def.
4. Get s_sub_super_instance by following INHERIT|P until the next P leads to s_super_def:
     query ()
       filter INHERIT? (P INHERIT)*
          and { s :- getGenericDef(s) == s_super_def }
           in s_sub |-> [(_, s_sub_super_instance)]
5. Check if instances are compatible: isTypeArgsCompatible(s_sub_super_instance, s_super)

inherits(s_sub, s_super):     checks that s_sub has a path to s_super via alternating INHERIT|P edges
isTypeArgsCompatible(s1, s2): given two instances of the same data type, check if s1 is a subtype of s2
getTypeArgs(s_data):          get all type arguments defined in s_data.
getGenericDef(s_data):        Get generic definition of s_data. Requires that s_data is an instance.
findGenericDef(s_data):       Get generic definition of s_data. s_data can be either an instance or the generic def itself.
*/

    // check if s1 is compatible with s2. Assumes s1 is an instance of data
    // type dt and that s2 is either also an instance or the generic definition
    // "Compatible" means that the types are equal, or the second one is a
    // wildcard and the first one falls within the bounds
    isTypeArgsCompatible : scope * scope -> BOOLEAN
    isTypeArgsCompatible(s1, s2) = isTypeArgsCompatible_1(s1, s2, getGenericDef(s1)).

      // Get generic definition for instance.
      getGenericDef : scope -> scope
      getGenericDef(s_data_instance) = getScope(occ) :-
        query () filter P in s_data_instance |-> [occ].

      // s1 is an instance
      // s2 is either an instance or a data definition.
      // third argument is data definition
      isTypeArgsCompatible_1 : scope * scope * scope -> BOOLEAN
      isTypeArgsCompatible_1(s1, s2, s2) = TRUE().
        // s2 is a generic data definition, s1 is an instance of it.
        // s1 is a subtype by definition.

      isTypeArgsCompatible_1(s1, s2, s_data_def) =
        // s2 is an instance of s_data_def
        allTrue(isTypeArgsCompatible_2(getTypeArgs(s1), s2)).

        getTypeArgs : scope -> list((TYPEID * TYPE))
        getTypeArgs(s_data) = getArgTypes(occs) :-
          query generic_arg in s_data |-> occs.

          getArgType : (path * (TYPEID * TYPE)) -> (TYPEID * TYPE)
          getArgTypes maps getArgType(list(*)) = list(*)
          getArgType((path, arg_ty)) = arg_ty.

      isTypeArgCompatible : (TYPEID * TYPE) * scope -> BOOLEAN
      isTypeArgsCompatible_2 maps isTypeArgCompatible(list(*), *) = list(*)
      isTypeArgCompatible((name, ty1), s2) =
        isTypeArgCompatible_1(ty1, resolveUniqueTypeArg(s2, name, name)).

        isTypeArgCompatible_1 : TYPE * TYPE -> BOOLEAN
        isTypeArgCompatible_1(ty, ty) = TRUE().
        isTypeArgCompatible_1(DataType(s1), DataType(s2)) = isTypeEqual(s1, s2).
        isTypeArgCompatible_1(T1, T2) = FALSE().

        isTypeEqual : scope * scope -> BOOLEAN
        isTypeEqual(s1, s2) = andB(isInstanceOf(s1, s2), isTypeArgsCompatible(s1, s2)).

        isInstanceOf: scope * scope -> BOOLEAN
        isInstanceOf(s1, s2) = isInstanceOf_listNonEmpty(occs) :-
          query () filter P in s1 |-> occs.

          isInstanceOf_listNonEmpty : list((path * scope)) -> BOOLEAN
          isInstanceOf_listNonEmpty([]) = FALSE().
          isInstanceOf_listNonEmpty([_|_]) = TRUE().

  isAssignableTo(_, TopType()) = TRUE().
  isAssignableTo(BottomType(), _) = TRUE().

/*

Given isAssignableTo(Wildcard(upper(Apple)), Fruit) -> yes, any type with upper bound apple could be assigned to fruit.
Given isAssignableTo(Wildcard(upper(Fruit)), Apple) -> maybe, wildcard could be Apple. Reject
isAssignableTo(Wildcard(lower(Fruit)), Apple) -> no, Apple is outside lower bound
isAssignableTo(Wildcard(lower(Fruit)), Food) -> maybe, Food is higher than Fruit. Reject
isAssignableTo(Food, Wildcard(lower(Fruit))) -> yes
isAssignableTo(Food, Wildcard(upper(Fruit))) -> no
isAssignableTo(Apple, Wildcard(upper(Fruit))) -> yes

isAssignableTo(Wildcard(upper(Apple)), Wildcard(upper(Fruit))) -> maybe -> reject
isAssignableTo(Wildcard(upper(Food)), Wildcard(upper(Fruit))) -> maybe -> reject
isAssignableTo(Wildcard(upper(Food)), Wildcard(lower(Fruit))) -> maybe -> reject
isAssignableTo(Wildcard(upper(Apple)), Wildcard(lower(Fruit))) -> yes

*/

  isAssignableTo(WildcardType(upper_bound, lower_bound), T) =
    andB(isUpperBoundAssignableTo(upper_bound, T), isLowerBoundAssignableTo(lower_bound, T)).

    isUpperBoundAssignableTo : UpperBoundType * TYPE -> BOOLEAN
    isUpperBoundAssignableTo(NoUpperBoundType(), _) = TRUE().
    isUpperBoundAssignableTo(UpperBoundType(upper_bound), T) = isAssignableTo(upper_bound, T).

    isLowerBoundAssignableTo : LowerBoundType * TYPE -> BOOLEAN
    isLowerBoundAssignableTo(NoLowerBoundType(), _) = TRUE().
    isLowerBoundAssignableTo(LowerBoundType(_), TopType()) = TRUE().
    isLowerBoundAssignableTo(LowerBoundType(_), _) = FALSE().

  isAssignableTo(T, WildcardType(upper_bound, lower_bound)) =
    andB(isAssignableToUpperBound(T, upper_bound), isAssignableToLowerBound(T, lower_bound)).

    isAssignableToUpperBound : TYPE * UpperBoundType -> BOOLEAN
    isAssignableToUpperBound(_, NoUpperBoundType()) = TRUE().
    isAssignableToUpperBound(BottomType(), UpperBoundType(_)) = TRUE().
    isAssignableToUpperBound(_, UpperBoundType(_)) = FALSE().

    isAssignableToLowerBound : TYPE * LowerBoundType -> BOOLEAN
    isAssignableToLowerBound(_, NoLowerBoundType()) = TRUE().
    isAssignableToLowerBound(T, LowerBoundType(lower_bound)) = isAssignableTo(lower_bound, T).

  isAssignableTo(T, T) = TRUE().
  isAssignableTo(_, _) = FALSE().

  /**
   * isAllAssignableTo(T1s, T2s) -> bool
   * Returns TRUE if the types in [T1s] are pairwise subtypes of [T2s], FALSE
   * otherwise. Also returns FALSE if the lists don't have the same length.
   * This is useful for comparing parameter lists of functions.
   * Delegates to isSubtype.
   */
  isAllAssignableTo : list(TYPE) * list(TYPE) -> BOOLEAN
  isAllAssignableTo([], []) = TRUE().
  isAllAssignableTo(Ts@[_|_], []) = FALSE().
  isAllAssignableTo([], Ts@[_|_]) = FALSE().
  isAllAssignableTo([T1|T1s], [T2|T2s]) = andB(isAssignableTo(T1, T2), isAllAssignableTo(T1s, T2s)).


  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  /**
   * makeNullable(ty)
   * Make Type [ty] nullable if it is not already.
   * This returns either NullType() or NullableType(_)
   */
  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(T) = NullableType(T).

  /**
   * lub(T1, T2)
   * Returns the least upper bound of types [T1] and [T2].
   */
  lub : TYPE * TYPE -> TYPE
  lubs maps lub(list(*), list(*)) = list(*)
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(NullableType(T1), NullableType(T2)) = NullableType(lub(T1, T2)).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(T1@DataType(_), T2@DataType(_)) = lub_dataTypeGuard(isAssignableTo(T1, T2), isAssignableTo(T2, T1), T1, T2).
  
    lub_dataTypeGuard : BOOLEAN * BOOLEAN * TYPE * TYPE -> TYPE
    lub_dataTypeGuard(TRUE(), _, _, T2) = T2.
    lub_dataTypeGuard(_, TRUE(), T1, _) = T1.
    lub_dataTypeGuard(FALSE(), FALSE(), T1@DataType(s1), T2@DataType(s2)) =
      lub_datatype(maybe_s_common, s1, s2)
    :-
      // find all scopes from s1 that s2 inherits from, take the shortest one.
      // This is guaranteed to be a generic definition unless one of the two is a subtype of the other,
      // or they do not have an explicit common super type.
      // them being subtypes is already covered by lub_dataTypeGuard
      query ()
        filter (P|INHERIT)*
           and { s_common_candidate :- inherits(s2, s_common_candidate) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> maybe_s_common.

    // list contains either no scopes or single scope s_data_common, which is a definition
    lub_datatype : list((path * scope)) * scope * scope -> TYPE
    lub_datatype([], _, _) = TopType().
    lub_datatype([(_, s_common)], s1, s2) = DataType(s_common_instance) :-
      {s3 s4 type_arg_names type_arg_tys merged_type_args}
      new s_common_instance,
      !root[getRoot(s_common)] in s_common_instance,
      s_common_instance -P-> s_common,
      query ()
        filter (P|INHERIT)*
           and { s3_candidate :- isInstanceOf(s3_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s1 |-> [(_, s3)],
      query ()
        filter (P|INHERIT)*
           and { s4_candidate :- isInstanceOf(s4_candidate, s_common) == TRUE() }
           min $ < INHERIT, $ < P in s2 |-> [(_, s4)],
      unzipTypeArgs(getTypeArgs(s3)) == (type_arg_names, type_arg_tys),
      // next line is incorrect, should use unbounded wildcard
      lubs(type_arg_tys, resolveUniqueTypeArgs(s4, type_arg_names, "no error node")) == merged_type_args,
      declareGenericArgs(s_common_instance, type_arg_names, merged_type_args).

        unzipTypeArgs : list((TYPEID * TYPE)) -> (list(TYPEID) * list(TYPE))
        unzipTypeArgs([]) = ([], []).
        unzipTypeArgs([(name, type)|type_args]) = ([name|names], [type|types]) :-
          unzipTypeArgs(type_args) == (names, types).

/*

Problem: given s1 and s2, find s_common such that either:
- inherits(s1, s3), inherits(s2, s4), typeArgsCompatible(s3, s_common) and typeArgsCompatible(s4, s_common) // s_common is an instance
- inherits(s1, s_common) and inherits(s2, s_common) // s_common is a generic definition

Solution for instances: find s_common_def, use lub on generic parameters
*/

  lub(TopType(), T) = TopType().
  lub(T, TopType()) = TopType().
  lub(BottomType(), T) = T.
  lub(T, BottomType()) = T.
  lub(WildcardType(upper_bound, _), T) = lub(typeOrTopType(upper_bound), T).
  lub(T, WildcardType(upper_bound, _)) = lub(T, typeOrTopType(upper_bound)).
  lub(T, T) = T.
  lub(T1, T2) = firstTrueT([
    (isAssignableTo(T1, T2), T2),
    (isAssignableTo(T2, T1), T1)],
    TopType()).


  /**
   * listLub(list)
   * Returns the least upper bound of a list of types.
   */
  listLub : list(TYPE) -> TYPE
  listLub([]) = BottomType() :- try { false } | warning "BUG?: called listLub with empty list".
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).

  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :- orB(isAssignableTo(T1, T2), isAssignableTo(T2, T1)) == TRUE().

rules

  /**
   * typeOf(s, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you have a scope with type arguments, use typeOfWithTypeArgScope
   */
  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)
  typeOf(s, ty) = typeOfWithTypeArgScope(s, emptyScope(s), ty).

  /**
   * typeOfWithTypeArgScope(s, s_type_args, ty) = type
   * Resolves a syntactic Type [ty] to a semantic TYPE [type] in scope [s].
   * If you have a scope with type arguments, use typeOfWithTypeArgScope
   */
  typeOfWithTypeArgScope : scope * scope * Type -> TYPE
  typesOfWithTypeArgScope_1 maps typeOfWithTypeArgScope(*, *, list(*)) = list(*)
  typeOfWithTypeArgScope(s, s_type_args, ty) = type@typeOfWithTypeArgScope_1(s, s_type_args, ty) :-
    @ty.type := type.

  typeOfWithTypeArgScope_1 : scope * scope * Type -> TYPE
  typeOfWithTypeArgScope_1(_, _, UnitTy()) = UnitType().
  typeOfWithTypeArgScope_1(_, _, BoolTy()) = BoolType().
  typeOfWithTypeArgScope_1(_, _, IntTy())  = IntType().
  typeOfWithTypeArgScope_1(_, _, StrTy())  = StrType().
  typeOfWithTypeArgScope_1(_, _, PathTy()) = PathType().
  typeOfWithTypeArgScope_1(s, s_type_args, DataTy2Type(data_ty)) = typeOfDataTy(s, s_type_args, data_ty).
  typeOfWithTypeArgScope_1(s, s_type_args, TupleTy(tys)) = TupleType(typesOfWithTypeArgScope_1(s, s_type_args, tys)).
  typeOfWithTypeArgScope_1(s, s_type_args, ListTy(ty)) = ListType(typeOfWithTypeArgScope_1(s, s_type_args, ty)).
  typeOfWithTypeArgScope_1(s, s_type_args, SupplierTy(ty)) = SupplierType(typeOfWithTypeArgScope_1(s, s_type_args, ty)).
  typeOfWithTypeArgScope_1(s, s_type_args, NullableTy(ty, marker)) = NullableType(typeOfWithTypeArgScope_1(s, s_type_args, ty)) :-
    try { ty != NullableTy(_, _) } | warning $[No-op: double nullable has no effect] @marker.
  typeOfWithTypeArgScope_1(s, s_type_args, Wildcard(upper_bound, lower_bound)) = WildcardType(upper_bound_ty, lower_bound_ty) :-
    {upper_error_node lower_error_node}
    typeOfUpperBound(s, s_type_args, upper_bound) == upper_bound_ty,
    typeOfLowerBound(s, s_type_args, lower_bound) == lower_bound_ty,
    bothBoundsOk(upper_bound, lower_bound).

      bothBoundsOk : UpperBound * LowerBound
      bothBoundsOk(_, _).
      bothBoundsOk(u@UpperBound(_), l@LowerBound(_)) :-
        false | error $[Cannot have both an upper and lower bound] @u,
        false | error $[Cannot have both an upper and lower bound] @l.

      typeOfUpperBound : scope * scope * UpperBound -> UpperBoundType
      typeOfUpperBound(_, _, NoUpperBound()) = NoUpperBoundType().
      typeOfUpperBound(s, s_type_args, UpperBound(upper_bound)) =
        UpperBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, upper_bound))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as upper bound] @upper_bound,
        try { ty != UnitType()   } | warning $[Nonsensical bound: unit does not have subtypes] @upper_bound,
        try { ty != ListType(_)  } | warning $[Nonsensical bound: list types do not have subtypes] @upper_bound,
        try { ty != TupleType(_) } | warning $[Nonsensical bound: tuple types do not have subtypes] @upper_bound,
        try { ty != BottomType() } | warning $[Nonsensical bound: BOTTOM is the only matching type] @upper_bound.

      typeOfLowerBound : scope * scope * LowerBound -> LowerBoundType
      typeOfLowerBound(_, _, NoLowerBound()) = NoLowerBoundType().
      typeOfLowerBound(s, s_type_args, LowerBound(lower_bound)) =
        LowerBoundType(ty@typeOfWithTypeArgScope(s, s_type_args, lower_bound))
      :-
        try { ty != WildcardType(_, _) } | error $[Cannot use wildcard as lower bound] @lower_bound,
        try { ty != TopType() } | warning $[Nonsensical bound: TOP is the only matching type] @lower_bound.

  typeOfDataTy : scope * scope * DataTy -> TYPE
  typeOfDataTy(s, s_type_args, data_ty@DataTy(modules, name, type_args)) = type :-
    {resolved_params resolvedData}
    resolveGenericParam(s_type_args, name) == resolved_params,
    resolveData(mergeScopes(s, resolveModuleListToFile(s, modules)), name) == resolvedData,
    isGenericParamOrDataTy(s, s_type_args, data_ty, modules, resolved_params, resolvedData) == type.

    isGenericParamOrDataTy : scope * scope * DataTy * ModuleList *
      list((path * (GenericParameter * (TYPE * TYPE)))) * list((path * (TYPEID * scope))) -> TYPE
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, [], []) = DataType(emptyScope(s)) :-
      false | error $[Undefined datatype [name]] @name.

    // generic parameter
    isGenericParamOrDataTy(s, s_type_args, DataTy(_, name, type_args), NoModuleList(), [(_, (GenericParameter(_, name'), (upper_bound, _)))], _) = type :-
      genericParamToType(resolveGenericArg(s_type_args, name), upper_bound) == type,
      @name.ref := name',
      @name.type := type.

      genericParamToType : list((path * (TYPEID * TYPE))) * TYPE -> TYPE
      genericParamToType([], upper_bound) = upper_bound.
      genericParamToType([(_, (_, ty))], _) = ty.

    isGenericParamOrDataTy(s, _, DataTy(_, name, type_args), NoModuleList(), [_,_|_], _) = DataType(emptyScope(s)) :-
      false | error $[Duplicate declarations for generic parameter [name]] @name.

    // data type
    isGenericParamOrDataTy(s, _, DataTy(_, name, _), _, _, [_,_|_]) = DataType(emptyScope(s)) :-
      false | error $[Duplicate datatype [name]] @name.
    isGenericParamOrDataTy(s, s_type_args, data_ty@DataTy(modules, name, TypeArgs(type_args)), _, _, [(_, (name', s_data_def))]) = type@DataType(s_data_instance) :-
      new s_data_instance,
      !root[getRoot(s)] in s_data_instance,
      s_data_instance -P-> s_data_def,
      genericArgsOk(s, s_type_args, s_data_instance, getGenericParams(s_data_def), type_args),
      @name.ref := name',
      @name.type := type.

      // s: current function/module scope
      // s_type_args: scope for looking up defined data types
      // s_data_instance: scope for the instance that we are typing right now
      // s_data_def: definition for s_data_instance

      genericArgsOk : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) * list(Type)
      genericArgsOk(s, s_type_args, s_data_instance, params, arg_types) :-
        genericArgsOk_1(s, s_type_args, s_data_instance, params, arg_types, sameLength(params, arg_types)).

        sameLength : list((GenericParameter * TYPE * TYPE)) * list(Type) -> (list(TYPEID) * list(Type))
        sameLength([], []) = ([], []).
        sameLength([(GenericParameter(_, name), _, _)|params], []) = ([name|names], []) :-
          sameLength(params, []) == (names, []).
        sameLength([], remaining@[_|_]) = ([], remaining).
        sameLength([_|params], [_|type_args]) = sameLength(params, type_args).

      genericArgsOk_1 : scope * scope * scope * list((GenericParameter * TYPE * TYPE)) * list(Type) * (list(TYPEID) * list(Type))
      genericArgsOk_1(_, _, _, _, arg_types, (remaining@[_|_], [])) :-
        false | error $[Not enough type arguments, unmatched generic arguments: [remaining]] @arg_types.
      genericArgsOk_1(_, _, _, _, arg_types, ([], remaining@[_|_])) :-
        false | error $[Too many type arguments, unmatched type arguments: [remaining]] @arg_types.
      genericArgsOk_1(s, s_type_args, s_data_instance, params, arg_types, ([], [])) :-
        genericArgsOk_2(s, s_type_args, s_data_instance, params, arg_types).

      genericArgOk : scope * scope * scope * (GenericParameter * TYPE * TYPE) * Type
      genericArgsOk_2 maps genericArgOk(*, *, *, list(*), list(*))
      genericArgOk(s, s_type_args, s_data_instance, (GenericParameter(_, name), upper_bound, lower_bound), arg) :-
        {arg_ty}
        typeOfWithTypeArgScope(s, s_type_args, arg) == arg_ty,
        declareGenericArg(s_data_instance, name, arg_ty),
        assignableTo(arg_ty, upper_bound) | error $[Type mismatch: [arg_ty] is not assignable to upper bound [upper_bound]],
        assignableTo(lower_bound, arg_ty) | error $[Type mismatch: [arg_ty] is not assignable from lower bound [lower_bound]].

  /**
   * getScopeFromType(s, ty)
   * Returns the scope with methods associated with type [ty]
   */
  getScopeFromType : scope * TYPE -> scope
  getScopeFromType(_, DataType(s_data)) = s_data.
  getScopeFromType(s, ty) = emptyScope(s).
