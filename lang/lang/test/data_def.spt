module data_def

language pie

fixture [[
  module test:data_def

  [[...]]

  data Command = foreign java org.example.test.dataDef.Command {}
]]

// general
test no datadef [[ ]] analysis succeeds
test datadef foreign java [[ data Foo = foreign java org.example.test.Foo {} ]] analysis succeeds
test duplicate name [[
  data [[Foo]] = foreign java org.example.test.Foo {}
  data [[Foo]] = foreign java org.example.test.Foo {}
]] 2 errors at #1, #2
   error like "Duplicate" at #1, #2

// data def mods
test transient datadef [[ transient data Foo = foreign java org.example.test.Foo {} ]] analysis succeeds
test double transient [[ transient transient data Foo = foreign java org.example.test.Foo {} ]] analysis fails

// generic parameters
test generic parameters omitted param list [[ [[data Foo = foreign java Foo {} ]] ]]
  analysis succeeds
  run desugar-all on #1 to DataDef(_, _, GenericParams([]), _, _)
test generic parameters empty param list [[ data Foo<> = foreign java Foo {} ]] analysis succeeds
test generic parameters single param unbound [[ data Foo<[[T]]> = foreign java Foo {} ]] analysis succeeds  run pie-get-type on #1 to TopType()
test generic parameters single param bound [[ data Foo<[[T]]: [[Command]]> = foreign java Foo {} ]] analysis succeeds  run pie-get-type on #1 to DataType(_)
test generic parameters shadow existing name [[ data Foo<[[Command]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to TopType()
  1 note at #1
  note like "shadows data type"
test generic parameters reference own type [[ data [[Foo]]<[[T]]: [[Foo]]<[[T]]>> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #2 to DataType(_)
  resolve #3 to #1
  resolve #4 to #2
test generic parameters bound is unit [[ data Foo<[[T]]: [[unit]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to UnitType()
  1 warning at #2
  warning like "unit does not have subtypes"
test generic parameters bound is list [[ data Foo<[[T]]: [[Command*]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to ListType(DataType(_))
  1 warning at #2
  warning like "list types do not have subtypes"
test generic parameters bound is tuple [[ data Foo<[[T]]: [[(path, Command)]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to TupleType([PathType(), DataType(_)])
  1 warning at #2
  warning like "tuple types do not have subtypes"
test generic parameters bound is supplier [[ data Foo<[[T]]: [[supplier<string>]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to SupplierType(StrType())
test generic parameters allow list type [[ data Foo<T: Bar*> : Object = foreign java Foo {} ]] parse succeeds
test generic parameters allow tuple type [[ data Bar<T: (Foo, Bak)> : Object = foreign java Foo {} ]] parse succeeds

test generic parameters two params unbound [[ data Foo<[[T]], [[R]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to TopType()
  run pie-get-type on #2 to TopType()
test generic parameters two params first bound [[ data Foo<[[T]]: Command, [[R]]> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to DataType(_)
  run pie-get-type on #2 to TopType()
test generic parameters two params second bound [[ data Foo<[[T]], [[R]]: string> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to TopType()
  run pie-get-type on #2 to StrType()
test generic parameters two params both bound [[ data Foo<[[T]]: int?, [[R]]: bool> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to NullableType(IntType())
  run pie-get-type on #2 to BoolType()
test generic parameters two duplicate name [[ data Foo<[[T]], [[T]]> = foreign java Foo {} ]]
  2 errors at #1, #2
  run pie-get-type on #1 to TopType()
  run pie-get-type on #2 to TopType()
  error like "Duplicate definition of generic parameter"
// test disabled: Statix does not terminate on circular generic references
//test generic parameters two params circular reference [[
//  data Foo<[[T]]: Foo<[[R]], [[R]]>, [[R]]: Foo<[[T]], [[R]]>> = foreign java Foo {}
//]]
//   analysis succeeds
//   run pie-get-type on #1 to DataType(_)
//   run pie-get-type on #2 to DataType(_)
//   resolve #2 to #4
//   resolve #3 to #4
//   resolve #5 to #1
//   resolve #6 to #4
test generic parameters two params both bound [[ data Foo<[[T]]: int?, [[R]], [[U]]: bool> = foreign java Foo {} ]]
  analysis succeeds
  run pie-get-type on #1 to NullableType(IntType())
  run pie-get-type on #2 to TopType()
  run pie-get-type on #3 to BoolType()

// supertypes
test supertype declaration before use [[
  data [[Bar]] = foreign java org.example.test.Bar {}
  data Foo : [[Bar]] = foreign java org.example.test.Foo {}
]] analysis succeeds
   resolve #2 to #1
test supertype use before declaration [[
  data Foo : [[Bar]] = foreign java org.example.test.Foo {}
  data [[Bar]] = foreign java org.example.test.Bar {}
]] analysis succeeds
   resolve #1 to #2
test supertype imported [[
  data [[Bar]] = foreign java org.example.test.Bar {}
  data Foo : test:data_def:[[Bar]] = foreign java org.example.test.Foo {}
]] analysis succeeds
   resolve #2 to #1
test supertype is self [[ data [[Foo]] : [[Foo]] = foreign java org.example.test.Foo {} ]]
  resolve #2 to #1
  1 error at #2
  error like "inherit" at #2
test supertype is self indirect [[
  data [[Foo]] : [[Bar]] = foreign java org.example.test.Foo {}
  data [[Bar]] : [[Foo]] = foreign java org.example.test.Bar {}
]] resolve #2 to #3
   resolve #4 to #1
   2 errors at #2, #4
   error like "inherit" at #2, #4
test supertype non-overriding methods [[
  data [[Bar]] = foreign java org.example.test.Bar {
    func get() -> int
  }
  data Foo : [[Bar]] = foreign java org.example.test.Foo {
    func set(int) -> unit
  }
]] analysis succeeds
   resolve #2 to #1
test supertype overriding, compatible methods [[
  data [[Foo]] = foreign java org.example.test.Foo {
    func [[get]]() -> [[Foo]]
  }
  data [[Bar]] : [[Foo]] = foreign java org.example.test.Bar {
    func [[get]]() -> [[Bar]]
  }
]] analysis succeeds
   resolve #3 to #1
   resolve #5 to #1
   resolve #6 to #2
   resolve #7 to #4
test supertype - non-overriding methods - different parameter count [[
  data Bar = foreign java org.example.test.Bar {
    func get() -> bool
  }
  data Foo : Bar = foreign java org.example.test.Foo {
    func get(int) -> int
  }
]] analysis succeeds
test supertype - overriding, incompatible methods - non-subtype return type [[
  data Foo = foreign java org.example.test.Foo {
    func [[get]]() -> Bar
  }
  data Bar : Foo = foreign java org.example.test.Bar {
    func [[get]]() -> Foo
  }
]] 1 error
   error like "incompatible return type"
   resolve #2 to #1
test supertype - non-overriding methods - narrowing parameter [[
  data Bar = foreign java org.example.test.Bar {
    func get(Bar) -> int
  }
  data Foo : Bar = foreign java org.example.test.Foo {
    func get(Foo) -> int // does not override get(Bar) above
  }
]] analysis succeeds
test supertype - non-overriding methods - different parameters types [[
  data Bar = foreign java org.example.test.Bar {
    func get(Bar, int) -> int
  }
  data Foo : Bar = foreign java org.example.test.Foo {
    func get(Foo, bool) -> int
  }
]] analysis succeeds



// implementation - foreign java - class def
test foreign java same class [[
  data Bar = foreign java org.example.test.Bar {}
  data Foo1 : Bar = foreign java org.example.test.Foo {}
  data Foo2 = foreign java org.example.test.Foo {}
  func takesFoo1(foo: Foo1) -> unit = {}
  func main(foo: Foo2) -> unit = takesFoo1([[foo]])
]] // Checks that:
   // Using the same class for different pie data types is allowed, even if the signatures don't match
   // Cannot use Foo2 where Foo1 is expected, even though both are the same Java class.
   1 error at #1

// implementation - foreign java - methods
test foreign java no methods [[ data Foo = foreign java org.example.test.Foo {} ]] analysis succeeds
test foreign java one method [[ data Foo = foreign java org.example.test.Foo {
  func get() -> int
} ]] analysis succeeds
test foreign java two methods [[ data Foo = foreign java org.example.test.Foo {
  func get() -> int
  func set(int) -> unit
} ]] analysis succeeds
test foreign java three methods [[ data Foo = foreign java org.example.test.Foo {
  func get() -> int
  func set(int) -> unit
  func getAndSet(int) -> int
} ]] analysis succeeds
test foreign java allow returning own type [[
  data [[Foo]] = foreign java org.example.test.Foo {
    func get() -> [[Foo]]
  }
]] analysis succeeds
   resolve #2 to #1
test foreign java allow taking own type [[
  data [[Foo]] = foreign java org.example.test.Foo {
    func set([[Foo]]) -> unit
  }
]] analysis succeeds
   resolve #2 to #1
test foreign java allow circular dependency [[
  data [[Bar]] = foreign java org.example.test.Bar {
    func get() -> [[Foo]]
  }
  data [[Foo]] = foreign java org.example.test.Foo {
    func get() -> [[Bar]]
  }
]] analysis succeeds
   resolve #2 to #3
   resolve #4 to #1
test foreign java allow same name methods in different datatypes [[
  data Bar = foreign java org.example.test.Bar {
    func get() -> int
  }
  data Foo = foreign java org.example.test.Foo {
    func get() -> int
  }
]] analysis succeeds
test foreign java disallow overloading method within datatype [[
  data Foo = foreign java org.example.test.Foo {
    func [[get]]() -> int
    func [[get]](int) -> unit
  }
]] 2 errors at #1, #2
   error like "Duplicate" at #1, #2

test foreign java wildcard as parameter type [[
  data Foo = foreign java org.example.test.Foo {
    func wildcardParam(param: [[_ : Command)]] -> unit
  }
]] 1 error at #1
   error like "Cannot use a wildcard"

test foreign java generic method parameter [[
  data Foo<[[T]]> = foreign java org.example.test.Foo {
    func set([[T]]) -> unit
  }
]] 1 error at #2
//   todo: implement resolution of generic parameters
//   analysis succeeds
//   resolve #2 to #1
test foreign java generic method return type [[
  data Foo<[[T]]> = foreign java org.example.test.Foo {
    func get() -> [[T]]
  }
]] analysis succeeds
//   todo: implement resolution of generic parameters
//   resolve #2 to #1
test foreign java generic method parameter and return type [[
  data Foo<[[T]]> = foreign java org.example.test.Foo {
    func duplicate(original: [[T]]) -> [[T]]
  }
]] 1 error at #2
//   todo: implement resolution of generic parameters
//   analysis succeeds
//   resolve #2 to #1
//   resolve #3 to #1

// todo: test that referencing generic parameter in supertype is not allowed:
// data Foo<T> = ...; data Bar : Foo<int> = ... { func get() -> T }
